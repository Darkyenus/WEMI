package wemi.util

import java.nio.file.Files
import java.nio.file.Path
import java.security.DigestInputStream
import java.security.MessageDigest
import java.util.*

/**
 * Convert [data] to hexadecimal number string.
 *
 * @see fromHexString
 */
fun toHexString(data: ByteArray): String {
    val chars = CharArray(data.size * 2)
    for (i in data.indices) {
        chars[2 * i] = Character.forDigit((data[i].toInt() ushr 4) and 0xF, 16)
        chars[2 * i + 1] = Character.forDigit(data[i].toInt() and 0xF, 16)
    }
    return String(chars)
}

/**
 * Convert hexadecimal number string, like one generated by [toHexString], to [ByteArray].
 *
 * Skips whitespace. Returns null when [data] contains non-whitespace that can't be converted to hexadecimal digit,
 * or when the amount of hexadecimal digits is odd.
 */
fun fromHexString(data: CharSequence): ByteArray? {
    val bytes = ByteArray(data.length / 2)
    var byteI = 0

    var lowByte = -1

    for (c in data) {
        if (c.isWhitespace()) continue
        val digit = Character.digit(c, 16)
        if (digit == -1) {
            return null
        }

        if (lowByte != -1) {
            bytes[byteI++] = (lowByte or digit).toByte()
            lowByte = -1
        } else {
            lowByte = digit shl 4
        }
    }

    if (lowByte != -1) {
        return null
    }

    return if (byteI == bytes.size) {
        bytes
    } else {
        Arrays.copyOf(bytes, byteI)
    }
}

/**
 * Hash the contents of this file using [algorithm] and return the result.
 *
 * Default algorithm is MD5, which is fast but not secure against attacks.
 */
fun Path.hash(algorithm: String = "MD5"): ByteArray {
    val md = MessageDigest.getInstance(algorithm)
    DigestInputStream(Files.newInputStream(this), md).use {
        val buf = ByteArray(1024)
        while (it.read(buf) != -1) {
        }
        it.close()
    }
    return md.digest()
}

